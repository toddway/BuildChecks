apply plugin: 'jacoco'
jacoco {
    toolVersion = "0.8.7"
    reportsDir = file("$buildDir/reports")
}

tasks.withType(Test) {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

project.afterEvaluate {
    if (project.hasProperty('android')) {
        if (android.hasProperty('applicationVariants')) {
            android.applicationVariants.all { variant -> createCoverageTask(variant) } //android app module
        } else if (android.hasProperty('libraryVariants')) {
            android.libraryVariants.all { variant -> createCoverageTask(variant) } //android library module
        }
    } else {
        createCoverageTask(null) //java library module
    }
}

def createCoverageTask(variant) {
    def variantName
    def testTaskName
    def javaPath
    def kotlinPath
    if (variant == null) {
        variantName = ""
        testTaskName = "test"
        javaPath = "${buildDir}/classes/java/${variantName}"
        kotlinPath = "${buildDir}/classes/kotlin/${variantName}"
    } else {
        variantName = variant.name
        testTaskName = "test${variantName.capitalize()}UnitTest"
        javaPath = "${buildDir}/intermediates/javac/${variantName}/classes"
        kotlinPath = "${buildDir}/tmp/kotlin-classes/${variantName}"
    }

    def excludes = [
            /*Android*/
            '**/R.class',
            '**/R$*.class',
            '**/BuildConfig.*',
            '**/Manifest*.*',
            'androidx/**/*.*',
            'android/**/*.*',

            /*Binding*/
            '**/*DataBinder*.*',
            '**/*DataBinding*.*',
            '**/*Binding*.*',
            '**/BR.class',

            /*Kodein*/
            '**/*ModuleKt*.*',

            /*AndroidAnnotations*/
            '**/*_.*',
            '**/*_$*',

            /*Dagger*/
            '**/*_Provide*/**',
            '**/*_*Factory*/**',
            '**/*_MembersInjector.class',
            '**/*Dagger*',

            /*Realm*/
            'io/realm/**/*.*',

            /*Tests*/
            '**/*Mock*.*',
            '**/*Test*.*',
            '**/*Null*.*'
    ]

    def javaClasses = fileTree(dir: javaPath, excludes: excludes)
    def kotlinClasses = fileTree(dir: kotlinPath, excludes: excludes)

    if (project.ext.changeList != null) {
        def includes = project.ext.changeList.size == 0
                ? ["**/IncludeNothing*"]
                : project.changeList.collect { value -> "**/${value.tokenize("/").last().tokenize(".").first()}*"}
        javaClasses.include(includes)
        kotlinClasses.include(includes)
    }

    tasks.create(name: "${testTaskName}Coverage", type: JacocoReport, dependsOn: "$testTaskName") {
        group = "Reporting"
        description = "Generate Jacoco coverage reports for the ${variantName.capitalize()} build."

        reports {
            html.enabled = true
            xml.enabled = true
        }

        classDirectories.from = files([javaClasses, kotlinClasses])

        sourceDirectories.from = files([
                "$project.projectDir/src/main/java",
                "$project.projectDir/src/${variantName}/java",
                "$project.projectDir/src/main/kotlin",
                "$project.projectDir/src/${variantName}/kotlin",
                "$project.projectDir/src/jvmMain/kotlin",
                "$project.projectDir/src/androidMain/kotlin",
                "$project.projectDir/src/commonMain/kotlin",
        ])

        executionData.from = files("${project.buildDir}/jacoco/${testTaskName}.exec")

        doFirst {
            try {
                def filesWithComposables = fileTree(kotlinPath)
                        .filter { it.text.contains("Landroidx/compose/runtime/Composer;") }
                        .collect {it.path.replaceAll(kotlinPath, "**") }
                excludes.addAll(filesWithComposables)
                kotlinClasses.exclude(excludes)
            } catch (e) {
                println(e.localizedMessage)
            }

        }
    }
}